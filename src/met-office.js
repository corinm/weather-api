const Promise = require('promise');
const rp = require('request-promise');
const Location = require('./location').Location;
const JsonProcessor = require('./json-processor').JsonProcessor;

class MetOffice {

  constructor() {
    // Options for requesting all Met Office locations
    this._optionsLocationRequest = {
      uri: 'http://datapoint.metoffice.gov.uk/public/data/val/wxfcs/all/json/sitelist',
      qs: {
        key: process.env.MET_KEY
      },
      json: true
    };

    this._optionsLatLongFromPostcode = {
      uri: 'https://api.postcodes.io/postcodes',
      qs: {
        q: ''
      },
      json: true
    };

    this._optionsTreeCreate = {
      method: 'POST',
      uri: process.env.TREE_API_URL + '/tree/create',
      body: {},
      json: true
    };

    this._optionsTreeSearch = {
      method: 'POST',
      uri: process.env.TREE_API_URL + '/tree/search',
      body: {},
      json: true
    };

    this._optionsForecastRequest = {
      uri: 'http://datapoint.metoffice.gov.uk/public/data/val/wxfcs/all/json/',
      qs: {
        res: '3hourly',
        key: process.env.MET_KEY
      },
      json: true
    };

    // Blank array of Met Office locations
    this._metLocations = [];
  };


  /**
   * Given a postcode and Met Office API, obtains weather forecast
   * @param {string} postcode - User's postcode
   * @param {string} apiKey - Met Office API Key
   */
  getWeather(postcode, apiKey, callback) {

    return this.getMetOfficeLocations() // A promise
      .then((locations) => {
        this.createTree(locations)
          .then((idAndSecret) => {
            this.searchTree(idAndSecret.id, idAndSecret.secret, postcode)
              .then((closestLocation) => {
                this.getForecasts(closestLocation.id)
                  .then((forecastsAll) => {
                    console.log(forecastsAll);
                    callback(forecastsAll);
                    return forecastsAll; // TODO: Need to return this only when ready
                  });


              });
          });

      })
  };


  /*
   * Returns Promise of an array of Met Office weather locations
   */
  getMetOfficeLocations() {

    return rp(this._optionsLocationRequest)
      .then((data) => {
        return data.Locations.Location

          // Convert into GeoTree object where data is Location object
          .map(location => {
            return {
              key1: parseFloat(location.latitude),
              key2: parseFloat(location.longitude),
              data: {
                id: location.id,
                name: location.name,
                area: location.unitaryAuthArea
              }
            };
          });
      })
      .catch((error) => {
        console.error(error);
      })

  };

  /*
   * Accepts a list of Location objects, returns id of created tree generated by kd-tree-api
   */
  createTree(locations) {

    let optionsTreeCreate = this._optionsTreeCreate;
    optionsTreeCreate.body = locations;

    return rp(optionsTreeCreate)
      .then((response) => {
        return {
          id: response.id,
          secret: response.secret
        }
      })
      .catch(function (err) {
        console.error(err);
      });
  };

  /*
   * Given a postcode and tree id, returns closest location for a weather report
   */
  searchTree(id, secret, postcode) {
    return this.getMyLatLong(postcode)
      .then((latLong) => {
        return {
          key1: latLong.latitude,
          key2: latLong.longitude
        }
      })
      .then((key) => {
        let optionsTreeSearch = this._optionsTreeSearch;
        optionsTreeSearch.body = {
          id: id,
          secret: secret,
          key: key
        };

        return rp(optionsTreeSearch)
          .then((response) => {
            return response;
          });
      });
  };

  /*
   * Get forecasts for a given Met Office id
   */
  getForecasts(metLocationId) {

    let optionsForecastRequest = this._optionsForecastRequest;
    optionsForecastRequest.uri += metLocationId;
    
    return rp(optionsForecastRequest)
      .then((response) => {
        const jp = new JsonProcessor();
        const json = jp.parseForecasts(response);
        return json;
      })

  };


  /*
   * Accepts a postcode, returns lat and long as an object
   */
  getMyLatLong(postcode) {
    let options = this._optionsLatLongFromPostcode;
    options.qs.q = postcode;
    return rp(options)
      .then((response) => {
        return response.result[0];
      })
      .then((location) => {
        return {
          latitude: parseFloat(location.latitude),
          longitude: parseFloat(location.longitude)
        }
      });
  };

}

module.exports.MetOffice = MetOffice;
